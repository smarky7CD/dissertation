As we have seen, compact probabilistic data structures are becoming ubiquitous in modern computing applications that deal with large amounts of data, especially when the data is presented as a stream. Many modern data warehousing and processing systems provide access to CPDS as part of their functionality.  A prominent example of such a system is Redis, a general purpose, in-memory database. Redis is integrated into general data analytics and computing platforms offered by AWS, Google Cloud, IBM Cloud, and Microsoft Azure, amongst others. Redis supports a variety of CPDS: HyperLogLog (HLL), Bloom filter, Cuckoo filter, t-digest, Top-K, and count-min sketch~\cite{redisPDS}. 
While Redis was mostly used as a cache in the past, it is now a fully general system, used by a companies like Adobe~\cite{Web:RedisForAdobe}, Microsoft~\cite{Web:RedisForMicrosoft}, Facebook~\cite{Web:RedisForFacebook} and Verizon~\cite{Web:RedisForVerizon} for a variety of purposes. These include security-related applications, such as traffic analysis and intrusion detection systems~\cite{Web:RedisForSiemens}.

As the functionality of Redis has broadened, so has its maturity with respect to security. Initially, the Redis developers stated that no security should be expected from Redis:
The Redis security model is: “it’s totally insecure to let untrusted clients access the system, please protect it from the outside world yourself”~\cite{antirez15}. In reality, users failed to comply with this~\cite{FiebigFP16}. Today, Redis has a number of security features, and has adopted a different model, with a protected mode as default, user authentication, use of TLS, and command block-listing amongst other features~\cite{redisSec}. Redis now also recognize security and performance in the face of adversarially-chosen inputs as being a valid concern, stating that ``an attacker might insert data into Redis that triggers pathological (worst case) algorithm complexity on data structures implemented inside Redis internals'' and then going on to discuss two potential issues, namely hash table exhaustion and worst-case sorting behavior triggered by crafted inputs~\cite{redisSec}. The first issue is prevented in Redis by using hash function seeding; the second issue is not currently addressed. However, Redis' consideration of malicious inputs does not seem to extend to their CPDS implementations.

Given its prominence in the marketplace and the many other systems that rely on it, we contend that the CPDS used in Redis are deserving of detailed analysis. Moreover, in view of the broad set of use cases for these CPDS, including those where adversarial interference is anticipated and would be damaging if successful, this analysis should be done in an adversarial setting. This approach follows a line of recent work on CPDS analysis~\cite{GerbetKL15,clayton2019,cardestprivacy,hllvuln,PatersonR22,markelon23}. In this paper, we make a comprehensive security analysis of the suite of CPDS provided by Redis, with a view to understanding how its constituent CPDS perform in adversarial settings. As argued in~\cite{cryptoeprint:2024/532}, we regard the observation, documentation, and analysis of such security phenomena ``in the wild'' as constituting scientific contributions in their own right.

Following prior work, we assume only that the adversary has access to the functionality provided by the CPDS (eg. via the presented API). The adversary's aim is then to subvert the main goal of the specific CPDS under study. 
We deliberately remain agnostic about precisely which application is running on top of Redis, since the relevant applications will change over time and are anyway largely proprietary. The real-world effects of a successful attack will vary across applications, but might include, for example, false statistical information being presented to users (in the case of frequency estimation), wrongly reporting the presence of certain data items in a cache (in the case of Bloom filters or Cuckoo filters) leading to performance degradation, or the evasion of network attack detection (in the case of cardinality estimation being used in network applications). 
Instead of making application-specific analyses, we focus on the core CPDS functionalities in Redis and how their goals can be subverted in general. Naturally, our analyses are specific to each of the different CPDS supported in Redis, and depend on various low-level implementation choices made by Redis. These choices lead us to develop novel attacks that are more powerful than the known generic attacks against the different CPDS in Redis.

Since HLL in Redis was already comprehensively studied in~\cite{PatersonR22}, we do not consider it further here. We note only that~\cite{PatersonR22} showed how to manipulate data input to Redis HLL to distort cardinality estimates in severe ways, in a variety of adversarial settings. The t-digest is a data structure first introduced in~\cite{dunning2021t}; it uses a k-means clustering technique~\cite{kodinariya2013review} to estimate percentiles over a collection of measurements. The structure is an outlier in the Redis CPDS suite as it does not work in the streaming setting, but necessitates the batching of data in memory, and it is not really probabilistic in the same sense as the other CPDS in Redis (in particular it does not employ the ``hash functions mapping to array positions" paradigm that the other CPDS in Redis use). For these reasons, we omit a security evaluation of t-digest (both in general and in the case of the Redis implementation).

This leads us to focus on the remaining four CPDS in Redis: Bloom filter, Cuckoo filter, Top-K, and count-min sketch. For each  CPDS, we discuss how the CPDS was originally described in the literature and lay out how the Redis implementation differs from this ``theoretical'' description. We then develop attacks for each of these four PDS, with the attacks in most cases exploiting specific features of the Redis implementations and being more efficient for this reason (simultaneously, we have to deal with the many oddities of the Redis codebase in our attacks). In total, we present 10 different attacks across the four CPDS. We compare our attacks with  known attacks for these CPDS from the literature. We also look at how the CPDS in Redis can be protected against attacks, drawing on existing literature that considers this question for CPDS more generally~\cite{clayton2019,FPUV22,PatersonR22,markelon23}. For the purposes of this work, we provide the structural descriptions and attacks for the compact frequency estimators implemented in Redis (Top-K and count-min sketch). Recall, that in~\Cref{chap:cfe} we saw that count-min sketch and HeavyKeeper (called Top-K in Redis) are susceptible to devastating attacks in even limited adversarial settings. In this chapter we demonstrate how these attacks are augmented by the specific implementation choices that Redis makes.Full details on the Bloom filter and Cuckoo filter are available in the full paper~\cite{cryptoeprint:2024/1312}.

Further, we notified Redis of our findings on 29.04.2024. The full version of our paper~\cite{cryptoeprint:2024/1312} is identical to the document we sent to Redis on 29.04.2024 aside from changes made in this subsection. We offered to engage in a coordinated approach to vulnerability disclosure and suggested a 90-day period before any public distribution of our research paper. Redis acknowledged our findings immediately and then gave a detailed response on 16.05.2024. In this response, Redis disputed the validity of analyzing Redis' CPDS in adversarial settings; naturally we disagree with their viewpoint. However, they also committed to consider changes to their implementation in future versions, including using random seeds instead of fixed seeds, considering alternative hash functions, and adding disclaimers to their documentation. They did not commit to a timeline for this consideration. They decided not to handle our disclosure as a ``Redis vulnerability".
