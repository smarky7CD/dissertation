\chapter{Compact Frequency Estimators in Adversarial Environments}\label{chap:cfe}

In this chapter, we focus on CPDS that can be used to estimate the number of times any particular element~$x$ appears in a collection of data, i.e., the frequency of~$x$. Such compact frequency estimators (CFEs) are commonly used in streaming settings, to identify elements with the largest frequencies ---~so-called heavy hitters or elephants.  Finding extreme elements is important for network planning~\cite{feldmann00}, network monitoring~\cite{lakhina04}, recommendation systems~\cite{melis2015efficient}, and approximate database queries~\cite{redisbloom}, to name a few applications.  

The Count-min Sketch (CMS)~\cite{cormode2005improved} and HeavyKeeper (HK)~\cite{yang2019heavykeeper} structures are two CFEs that we consider, in detail.
The CMS structure has been widely applied to a number of problems outlined above. Details on these applications are thoroughly examined in the survey paper by Sigurleifsson et al.~\cite{sigurleifsson2019overview}. The HK structure is the CFE of choice in the RedisBloom module~\cite{redisbloom}, a component of the Redis database system~\cite{redis}.  

Of particular interest to us is the 2019 ACM SIGSAC work of Clayton, Patton, and Shrimpton~\cite{clayton2019} that both furthers the adversarial analysis on Bloom filters and also presents a general model for analyzing probabilistic data structures for provable security. This paper gives a first look at the security of the Count-min sketch in adversarial environments. However, in this paper a very conservative security model for the CMS was used, which counted any overestimation of a particular element as an adversarial gain, rather than tying the security to the non-adaptive guarantees of the structure. Further, a thresholding mechanism is used to achieve security for the CMS, a solution which we deem untenable for real world uses of the CMS. 

As is the case for Bloom filters, HyperLogLog and other CPDS, the accuracy guarantees for CFEs effectively assume that the data they represent were produced by a non-adaptive strategy.  Our work explores the accuracy of CMS and HK estimates when the data is produced by adaptive adversarial strategies (i.e., adaptive attacks).  We give explicit attacks that aim to make as-large-as-possible gaps between the estimated and true frequencies of data elements.  We give concrete, not asymptotic, expressions for these gaps, in terms of specific adversarial resources (i.e., oracle queries), and support these expressions with experimental results.  And our attacks fit within a well-defined ``provable security"-style attack model that captures four adversarial access settings: whether the CFE representations are publicly exposed (at all times) or hidden from the adversary, and whether the internal hash functions are public (i.e., computable offline) or private (i.e. visible only, if at all, by online interaction with the structure).

In this work we draw explicit attention to the fact that compressing probabilistic data structures, and in particular frequency estimators, were not designed with security in mind by presenting attacks that degrade the correctness of the query responses these structures provide.  

Our findings are negative in all cases.  No matter the combination of public and private, a well resourced adversary can force CMS and HK estimates to be arbitrarily far from the true frequency. As one example of what this means for larger systems, things that have never appeared in the stream can be made to look like heavy hitters (in the case of CMS), and legitimate heavy hitters can be made to disappear entirely (in the case of HK).  This is somewhat surprising in the ``private-private'' setting, where the attack can only gain information about the structure and its operations via frequency estimate queries.  Of course, there are differences in practice: when attacks are forced to be online, they are easier to detect and throttle, so the query-resource terms in our analytical results are likely capped at smaller values than when some or all of an attack can progress offline. 

Our attacks exploit structural commonalities of CMS and HK.  At their core, each of these processes incoming data elements by mapping them to multiple positions in an array of counters, and these are updated according to simple, structure-specific rules. Similarly, 
when frequency estimation (or point) queries are made, the queried element is mapped to its associated positions, and the response is computed as a simple function of values they hold.  So, our attacks concern themselves with finding cover sets: given a target~$x$, find a small set of data elements (not including~$x$) that collectively hash to all of the positions associated with~$x$. Intuitively, inserting a cover set for~$x$ into the stream will give the structure incorrect information about~$x$'s relationship to the stream, causing it to over- or underestimate its frequency. 

The existence of a cover set in the represented data is necessary for producing frequency estimation errors in HK, and both necessary and sufficient in CMS.  Sadly, our findings suggest that preventing an adaptive adversary from finding such a set seems futile, no matter what target element is selected.  The task can be made harder by increasing the structural parameters, but this quickly leads to structures whose size makes them unattractive in practice, i.e., linear in the length of the stream.

We now motivate a robust CFE. Say that the array~$M$ in CMS has~$k$ rows and $m$~counters (columns) per row.
The CMS estimate for~$x$ is $\hat{n}_x=\min_{i \in [k]} \{M[i][p_i]\}$, where $p_i$ is the position in row~$i$ to which~$x$ hashes.  In the insertion-only stream model it must be that $\hat{n}_x \geq n_x$, where~$n_x$ is the true frequency of~$x$. To see this, given an input stream~$\streamvar{S}$,
let $V^{i}_{x}=\{y \in \streamvar{S} \,|\, y\neq x \mbox{ and } h_i(y)=p_i\}$ be the set of elements that hash to the same counter as~$x$, in the $i$-th row.  Then we can write $M[i][p_i]=n_x + \sum_{y \in V^i_x }n_y$, where the $n_y > 0$ are the true frequencies of the colliding~$y$s.
Viewed this way, we see that the CMS estimate~$\hat{n}_x$ minimizes the impact of ``collision noise'', i.e., 
$\hat{n}_x = n_x + \min_{i \in [k]}\{\sum_{y \in V^i_x }n_y\}$.  

We could improve this estimate if we knew some extra information about the value of the sum, or the elements that contribute to it. 
Let's say that, with a reasonable amount of extra space, we could compute $C_i = \epsilon_i \left(\sum_{y \in V^i_x }n_y\right)$ for some $\epsilon_i \in [0,1]$ that is bounded away from zero. Then we would improve the estimate to
$
\hat{n}_x = n_x + \min_{i \in [k]}\left\{(1-\epsilon_i)\left(\sum_{y \in V^i_x }n_y\right)\right\}
$.
How might we do this? Consider the case that for some row~$i \in [k]$ there is an element~$y^* \in V^{i}_{x}$ that dominates the collision noise, e.g. $n_{y^*} = (1/2)\sum_{y \in V^i_x }n_y$.  Then even the ability to accurately estimate $n_{y^*}$ would give a significant improvement in accuracy of $\hat{n}_x$, by setting~$C_i$ to this estimate. It turns out that HK provides something like this. It maintains a $k \times m$ matrix~$A$, where $A[i][j]$ holds a pair $(\mathrm{fp},\mathrm{cnt})$. In the first position is a fingerprint of the current ``owner'' of this position, and, informally, $\cnt$ is the number of times that~$A[i][j]$ ``remembers'' seeing the current owner.  (Ownership can change over time, as we describe in the body.) If we use the same hash functions to map element~$x$ into the same-sized~$M$ and~$A$, then there is possibility of using the information at~$A[i][p_i]$ to reduce the additive error (w.r.t. $n_x$) in the value of~$M[i][p_i]$.  This observation forms the kernel of our new Count-Keeper structure.

That is, we propose a new structure that, roughly speaking, combines equally sized (still compact) CMS and HK structures, and provide analytical and empirical evidence that it reduces the error (by at least a factor of two) that can be induced once a cover set is found. It also requires a type of cover set that is roughly twice as expensive (in terms of oracle queries) to find. Moreover, it can effectively detect when the reported frequency of an element is likely to have large error. In this way we can dampen the effect of the attacks, by catching and raising a flag when a cover set has been found and is inserted many times to induce a large frequency error estimation on a particular element.

Intuitively, our Count-Keeper (CK) structure has improved robustness against adaptive attacks because CMS can only overestimate the frequency of an element, and HK can only underestimate the frequency (under a certain, practically reasonable assumption). We experimentally demonstrate that CK is robust against a number of attacks we give against the other structures. Moreover, it performs comparably well if not better than the other structures we consider in frequency estimation tasks in the non-adversarial setting.


%-------------------------------------------------------------------------------
\section{Formal Attack Model}\label{sec:adv}
\input{chapters/ch3_cfe/ch3_sections/adv.tex}

%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\section{Count-min Sketch}\label{sec:cms}
   \input{chapters/ch3_cfe/ch3_sections/cms_code_fig.tex}
   \input{chapters/ch3_cfe/ch3_sections/cms.tex}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\section{HeavyKeeper}\label{sec:hk}
   \input{chapters/ch3_cfe/ch3_sections/hk_code_fig.tex}
   \input{chapters/ch3_cfe/ch3_sections/hk.tex}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\section{Attacks on CMS and HK}\label{sec:attacks}
\input{chapters/ch3_cfe/ch3_sections/attacks/attacks.tex}
%-------------------------------------------------------------------------------

%------------------------------------------------------------------------------- 
\section{Count-Keeper}\label{sec:ck}
\input{chapters/ch3_cfe/ch3_sections/ck/ck-main.tex}
%------------------------------------------------------------------------------- 