Informally, one can think of a probabilistic skipping-based data structure as a data structure that uses some form of randomness (either fixed at initialization time or freshly sampled per operation) to distribute the underlying collection within its representation. This randomized representation is to (generally) allow for efficient search by ``skipping'' over some elements, such that the resulting expected runtime is sublinear with high probability. 

For instance, hash tables employ a hash function to ``randomly'' map elements to buckets, and therefore, one only has to search in this bucket for a desired element. Likewise, skip lists randomly assign heights to elements to facilitate ``skipping'' over a sequence of elements while performing a search. While the treap randomly assigns priority values to maintain an (approximately) balanced tree representation.  In turn, the hash table achieves non-adaptive adversarial expected runtime~$O(1)$ for insertions, deletions, and search; similarly, the skip list and treap achieve non-adversarial expected runtime~$O(\log n)$ for these operations on an ordered collection (but has other advantages such as supporting range queries). 

In contrast to compressing probabilistic data structures (e.g., Bloom filters, count-min sketches, HyperLogLogs, etc.), PSDS always return a correct~$\Qry$ response. Further, unlike self-balancing data structures (e.g., splay trees, red-black trees, sorted arrays, etc.), skipping data structures do not require complex update mechanisms to maintain favorable representations. That is, under non-adversarial conditions, using randomness is sufficient to facilitate efficient operational runtimes (with high probability) without the overhead of complex and potentially expensive rebalancing algorithms. 

While this provides an intuitive notion of a skipping-based data structure, it fails to provide a formal or constructive definition. Therefore, let us consider the following. Take a hash table, whose representations are built over a size~$n$ set of elements (index keys) from the domain~$\{0,1\}^\secpar$ by running them each through a hash function and putting them into a bucket depending on the output of this hash function. Under the assumption that the hash function is uniform and the non-adversarial assumption that the set of elements is selected uniformly at random from the universe of all elements, then the elements in the table can be viewed as an (unordered) sequence of i.i.d. random variables. That is, we can decompose a hash table's representation as~$B_1,B_2,\ldots,B_N$ where~$\forall i \in [n]: B_{i} \sim \mathsf{U}(\{1,2,\ldots,b\})$, where~$b$ is the number of buckets for the particular structure.

For a skip list, we can take a similar view. Here, we again assume that a skip list represents a size~$n$ set of elements from the domain~$\{0,1\}^\secpar$. Additionally, we assumed that the set is well-ordered. Under the non-adversarial assumption that all updates are made uniformly at random from the universe of all elements, the representation can be viewed as a sequence of ordered i.i.d.~random variables (again, in the adaptive adversarial setting independence of these random variables does not necessarily hold). We can decompose the skip list representation as~$H_1,H_2,\ldots,H_N$ where~$\forall i \in [n] : H_{i} \sim \mathsf{G}(p)$ for the geometric distribution, where~$p$ is the probability parameter of the structure. That is, a skip list can be viewed as the ordered sequence of its elements heights. The sequence of random variables~$H_1,H_2,\ldots,H_N$ (heights) is sorted according to the order of the keys in the representation. Similarly, one can decompose the treap representation as~$P_1,P_2,\ldots,P_N$ where~$\forall i \in [n] : P_{i} \sim \mathsf{U}([0,1])$.  This sequence of random variables represents the priority of elements in the treap, and the sequence is again ordered by the keys in the representation. That is, treaps can be viewed as a binary search tree where the order of insertion is determined by the randomly sampled priorities~\cite{seidel1996randomized}. 

With this intuition built, we arrive at our definition for probabilistic skipping-based data structures. 

\begin{definition}[Probabilistic Skipping-Based Data Structure]
\label{def:sbds}
A probabilistic skipping-based data structure that represents a size~$n$ collection of elements from the domain~$\{0,1\}^\lambda$ is a data structure whose representation can be decomposed as a sequence of identically distributed random variables from some distributions~$\mathcal{X}$. This sequence is either unordered (for data structures representing unordered data, like hash tables) or implicitly ordered by some well-defined ordering over the domain of the underlying collection (as is the case for ordered data structures, like skip lists and treaps). 
\end{definition}

This definition offers a few key advantages. First, from an attack perspective, it helps us formally specify the necessary conditions for an adversary to succeed in our security game. For hash table attacks, this means forcing a large portion of the discrete uniform random variables $B_1, B_2, \ldots, B_n$ to be equal -- a condition any successful attack strategy must achieve to degenerate the data structure. Additionally, it allows us to precisely differentiate between adaptive and non-adaptive adversarial capabilities. When decomposing a skip list into geometric random variables $H_1, H_2, \ldots, H_N$ (sorted according to key order), an adaptive adversary can observe previous outcomes and strategically insert a new $H_i$ at any position in the sequence, thereby creating dependencies among the variables. In contrast, a non-adaptive adversary cannot observe previous geometric random variable outcomes, resulting in a final sequence $H_1, H_2, \ldots, H_N$ that maintains independence among the sequence of random variables. 

Second, this stochastic formalization enables the application of well-established probabilistic techniques to derive tight bounds on adversarial success probabilities: balls-and-bins analysis for hash tables and martingale-based arguments for skip lists and treaps. Finally, for researchers looking at different PSDS from the ones we consider, it allows for generalization of our robust data structures: proving security for one structure characterized by a particular sequence of identically distributed random variables allows us to transfer robustness techniques to other structures of the same type. Though specific structural details may prevent exact technique transfer, this approach should inform effective general strategies.

\subsection{Timing Side Channels}
\label{sec:side}

PSDS share a critical vulnerability: their runtime variation for distinct queries directly reveals information about their internal structure. This inherent timing side-channel has been successfully exploited in attacks against hash tables with (secret) salts~\cite{bar2007remote} and skip lists~\cite{nussbaum2019skiplist}. For treaps, this vulnerability also manifests, as runtime correlates with node depth, potentially exposing the complete internal structure when combined with the ordering of the inserted elements. While remote attackers might face challenges like network latency in precisely measuring timing differences, recent research demonstrates that timing side-channels can be exploited with remarkable precision -- as shown in \cite{ji2025your}, where researchers recovered an AES key from a Bluetooth chip's hardware accelerator.

Implementing enforced constant-time operations fails as a solution, as this would require the data structure to always operate at worst-case (linear) time, defeating the purpose of using these efficient structures. Similarly, making the data structure oblivious to prevent information leakage has significant limitations. Such approaches are inherently fragile -- once an adversary learns anything about the internal structure, the security guarantees collapse entirely. As aforementioned, previous attempts to prevent information leakage in skip lists~\cite{nussbaum2019skiplist} by randomly swapping elements have proven unsuccessful.

Given these considerations, we adopt a more realistic approach by considering a very strong adversarial model. We grant the adversary full access to the internal structure of the PSDS, then prove that even with this knowledge, they cannot successfully degenerate the structure. This robust security model acknowledges that side channels inevitably exist in practical implementations and builds defenses that remain effective despite full information leakage. While this represents a strong adversarial capability, we argue it better reflects real-world threat scenarios than a model that assume perfect or partial information hiding.

\subsection{Towards Robust PSDS}

We observe that two abilities allow an adaptive adversary to shape the distribution of data in a PSDS such that subsequent operations on the structures are degraded with high probability. The first is the ability to delete elements. This allows an adversary to degenerate a structure after a series of insertions by deleting unfavorable (w.r.t. to the adversary's goal) elements. The second is the ability of the adversary to influence where a particular element gets placed in the structure upon insertion. This is akin to knowing in advance which bucket an element will be inserted into in a hash table, at what position and height an element will be inserted in a skip list, or the priority an element will receive upon insertion to a treap. Therefore, we propose two inexpensive and general modifications to the base PSDS to make them robust in an adversarial setting. We will later prove these modified structures secure. 

\subsubsection{Lazy deletion} The first modification prevents the adversary from deleting (unfavorable) elements from the structure. This stultifies the ability of an adversary to perform a skip list degeneration-style attack, even with full access to the data structure's internal state. 

Removing the deletion functionality entirely from our data structure would be undesirable. Instead, we use a simple scheme that allows for removing elements without modifying the underlying structure of a PSDS that previous insertions have imposed. We achieve this by simply labeling an element as ``deleted''. For the hash table, we replace the element's label (e.g., the key-value data) with a distinguished symbol~$\diamond$ but do not modify the linked list in a hash table bucket by removing the node. For operational reasons, in the skip list and treap, we store a bit along with each node that indicates whether an element has been removed, but do not overwrite the originally inserted key with a distinguished symbol. 

This change prevents the adversary from eliminating desired skip connections in a skip list, obtaining trivial wins in our security model against a hash table (when taking the represented set to be the collection of all empty and non-empty elements), or only allowing elements to persist solely on the longest path in a treap. However, this modified deletion functionality affects the space efficiency of the structures. In later sections, we discuss approaches to ameliorating such concerns and analyze the trade-offs of these approaches. Lastly, since ``all bets are off'' when deletions are allowed, we implicitly provide security bounds that would compare to insertion-only versions of these structures in the non-adaptive case. That is, since an adaptive adversary can pathologically degrade the base structures, we enforce that using our modified deletion mechanisms never helps the adversary achieve their goal (in fact, this point is the first step of all our security proofs). 

\subsubsection{Adversarial robustness}
The second modification eliminates (to the greatest extent possible) an adversary's ability to predict element placement within data structures. All analyzed data structures require distinct security approaches for adversarial robustness, which heavily depends on how randomness is used internally. Skip lists and treaps use per-insertion randomness while preserving key-based ordering. During queries, the element's key guides traversal, although specific paths vary based on insertion-time randomization. Hash tables function fundamentally differently -- they determine bucket placement solely based on random experiment outcomes rather than element keys. This approach necessitates reproducing identical outcomes during search queries. Conventional implementations rely on public hash functions, creating a critical security vulnerability: adversaries can precalculate outcomes for elements and execute complexity attacks.

To provide adversarial robustness for hash tables, we replace public hash functions with secretly keyed primitives that effectively behave like truly random functions, preventing adversarial precalculation. Note that this approach necessitates secret key management, which presents potential implementation challenges. For skip lists, we develop an unkeyed, algorithmic approach to secure against adversarial manipulation. Despite an adversary's inability to have a priori knowledge of coin flip outcomes that determine the height of an element, skip lists remain vulnerable -- an adversary can strategically shift unfavorable random outcomes to one side of the structure, effectively placing elements with specific heights at chosen positions. We counter this by enforcing a local balance in the internal representation through a constant overhead swap operation, making such attacks exponentially more difficult.

Note that simply pre-applying a (secretly-keyed) random function to the items a skip list stores, as in the hash table mechanism, would alter the structure's ordering, rendering these data structures incapable of performing range queries, join operations, and other order-dependent functions. We therefore developed security mechanisms that maintain fundamental ordering properties while enhancing attack resilience.

Treaps, by contrast,inherently rebalance their entire structure based on the priorities of all previously inserted elements. As we will demonstrate, this property already substantially reduces an adversary's ability to place elements at positions of their choosing.