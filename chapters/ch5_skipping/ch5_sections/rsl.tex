\subsection{Insecurity of Standard Skip Lists}\label{sec:gap-attack}

As noted in~\cite{pugh}, the heights of the elements in the skip list must be kept secret, or otherwise, the skip list can be degenerated by simply deleting all elements in the list that are not at height zero. In our security model, this attack is trivial. However, even when disallowing deletions (or using our modified deletion) functionality, an adaptive adversary can still degenerate the skip list using a powerful but subtle strategy. We call this the \emph{gap attack} and detail it next, but use an intuitive rather than a formal description.

We assume the skip list takes values from $\{0,1\}^n$, which we interpret as integers between $0$ and $2^n-1$. The gap attacker proceeds as in Figure~\ref{fig:gap}. It starts by inserting an element in the middle $M=2^{n-1}$ of the interval $[L,R]=[0,2^{n}]$. If this element gets assigned a height of $0$ in the skip list, i.e., is only inserted in the bottom list, then the attacker secures it by shifting the left bound $L$ of the interval to $M$, moving to that gap. In the other case, if the height is large, it ``gives up'' this part of the skip list and moves the right bound $R$ of the interval to $M$. Continue with the new interval $[L',R']$ of half the size until $n$ elements have been inserted.
\begin{figure}[thp]
%	\Wider[4em]{
		\centering
		\begin{pchstack}[boxed,center,space=0.5em]
            \procedure[linenumbering, headlinecmd={\vspace{.1em}\hrule\vspace{.1em}}]{Gap attack on skip list}{%
                L \gets 0, R\gets 2^{n}\\
                \pcfor i \gets 1 \ \mathbf{to} \ n\\
                \t \text{insert element $ M\gets (R+L)/2 $}\\
                \t \pcif \text{height}(M)=0 \pcthen L\gets M \ \pcelse R\gets M
            }
		\end{pchstack}
%	}
  \caption[The Gap Attack.]{The gap attack on skip lists, inserting $n$ elements from $\{0,1\}^n$.   
  } 
  \label{fig:gap}
\end{figure}

By construction, the value $M$ in each iteration is always an integer between $L$ and $R$. Moreover, at the end of each iteration, there are only elements of height $0$ in the interval $[0,L]$ (if any), and all elements of larger height in $[R,2^{n}]$ (if any), since we set the left resp.~right bound accordingly in each iteration. 
Hence, after $n$ iterations and $R-L=1$ we have all elements of height $0$ in $[0,L]$, and elements of larger height in $[L+1,2^{n}]$. 
In each iteration, we insert an element of height $0$ with constant probability $1-p$, which will eventually lie in the interval $[0,L]$. Therefore, the expected number of elements in $[0,L]$ is $(1-p)n$.
%
The resulting skip list is now highly degenerated in the interval $[0,L]$. Specifically, it corresponds to a simple linked list of average length $(1-p)n$ in this part. Hence, the search for the element $L$ takes linear time on average, whereas a regular skip list would yield a logarithmic average search time. This is an exponential blow-up in running time, which the gap attacker enforces.

\subsection{A Robust Construction}

\begin{figure*}[thp]
    %	\Wider[4em]{
    %	\Wider[4em]{
            \centering
            \begin{pchstack}[boxed,center,space=0.5em]
                \begin{pcvstack}[space=0.45em]
                        \procedure[linenumbering, headlinecmd={\vspace{.1em}\hrule\vspace{.1em}}]{$\Rep_{\key}(\setS)$}{%
                            \mathsf{h} \gets \schemefont{NewNode}(m,\star)\\
                            \llst.\hdr \gets \mathsf{h}, \;
                            \llst.\lvl \gets 1\\
                            \pcfor (x,v) \in \setS \\
                            \t \llst \gets \Up_{\key}(\llst,\ins_{(x,v)})\\						
                            \pcreturn \llst
                        }
                        \procedure[linenumbering, headlinecmd={\vspace{.1em}\hrule\vspace{.1em}}]{$\schemefont{NewNode}(\ell,(x,v))$}{%
                            \pccomment{array position $0$ is reserved for}\\
                            \pccomment{a deleted bit, key, value triple $(d,x,v)$}\\
                            \pccomment{accessible via $n.\delacc$, $n.\keyacc$ and $n.\valueacc$}\\
                            \pccomment{array positions $1 \ldots \ell$ are forward pointers}\\
                            \pccomment{level is accessible via $n.\lvl$}\\
                            \node \gets \kwnew\; [0,..,\ell]\\
                            \node[0] \gets (\bot, x,v)\\
                            \pcfor i \gets \ell \ \mathbf{downto} \ 1 \pcdo\\
                            \t \node[i] \gets \nlll\\
                            \pcreturn \node
                        }
                        \procedure[linenumbering, headlinecmd={\vspace{.1em}\hrule\vspace{.1em}}]{$\schemefont{RandomLevel}_{\key}(\boxed{x})$}{%
                            \boxed{\ell \gets R(\key,x,m,p)}\\
                            \boxed{\pcreturn \ell}\\
                            \ell \gets 1, \;
                            r \getsr [0,1)\\
                            \pcwhile r < p \ \mathbf{and} \ \ell < m \pcdo\\
                            \t \ell \gets \ell + 1, \; r \getsr [0,1)\\
                            \pcreturn \ell
                        }
                       \procedure[linenumbering, headlinecmd={\vspace{.1em}\hrule\vspace{.1em}}]{$\Qry(\llst,\qry_{x})$}{%
                          c \gets \llst.\hdr\\
                            \pcfor i \gets \llst.\lvl \ \mathbf{downto} \ 1 \pcdo\\
                            \t \pcwhile c[i] \neq \nlll \ \mathbf{and} \ c[i][0].\keyacc < x \pcdo \\
                            \t \t c \gets c[i]\\
                            c \gets c[1]\\
                            \pcif c \neq \nlll \ \mathbf{and} \  c[0].\keyacc = x \ \mathbf{and} \ c[0].\delacc \neq \bot \pcthen\\
                            \t \pcreturn c[0].\valueacc \\
                            \pcelse \\
                            \t \pcreturn \star
                        }
                \end{pcvstack}	
                \begin{pcvstack}[space=0.45em]
                        \procedure[linenumbering, headlinecmd={\vspace{.1em}\hrule\vspace{.1em}}]{$\Up_{\key}(\llst,\ins_{(x,v)})$}{%
                            \mathsf{u} \gets \kwnew  [1,..,m] \pccomment{local array of pointers}\\
                            c \gets \llst.\hdr\\
                            \pcfor i \gets \llst.\lvl \ \mathbf{downto} \ 1 \pcdo\\
                            \t \pcwhile c[i] \neq \nlll \ \mathbf{and} \ c[i][0].\keyacc < x \pcdo \\
                            \t \t c \gets c[i]\\
                            \t u[i] \gets c\\
                            c \gets c[1] \\
                            \pcif c \neq \nlll \ \mathbf{and} \  c[0].\keyacc = x \pcthen\\
                            \t c[0].\valueacc \gets v,\; 
                            c[0].\delacc = \bot\\
                            \pcelse\\
                            \t \ell \gets \schemefont{RandomLevel}_{\key}(\boxed{x})\\
                            \t \pcif \ell > \llst.\lvl \pcthen \\
                            \t\t \pcfor i \gets \llst.\lvl + 1 \ \mathbf{upto} \ \ell \pcdo\\
                            \t\t\t \mathsf{u}[i] \gets \llst.\hdr\\
                            \t\t \llst.\lvl \gets \ell\\
                            \t \mathsf{n} \gets \schemefont{NewNode}(\ell,(x,v))\\
                            \t \pcfor i \gets 1 \ \mathbf{upto} \ \ell \pcdo\\
                            \t \t \mathsf{n}[i]\gets \mathsf{u}[i][i] ,\;
                            u[i][i]  \gets \mathsf{n}\\
                            \pccomment{find layer $\ell-1$ middle element using tortoise and hare} \\
                            \t \mathsf{middle} \gets u[\ell], \; \mathsf{fast} \gets u[\ell]\\
                            \t \pcwhile \mathsf{fast}  \neq \mathsf{n}[\ell] \ \mathbf{and} \ \mathsf{fast}[\ell-1] \neq \mathsf{n}[\ell] \pcdo \\
                            \t \t \mathsf{middle} \gets \mathsf{middle}[\ell-1], \;
                            \mathsf{fast} \gets \mathsf{fast}[\ell-1][\ell-1]\\
                            \pccomment{swapping logic} \\
                            \t \pcif \ell > \mathsf{middle}.\lvl \pcthen\\
                            \t \t \mathsf{middle}.\mathsf{append}(\mathsf{n}[\ell]), \;
                            \mathsf{n} \gets \mathsf{n}[0:\ell-1]\\
                            \t \t u[\ell][\ell] \gets \mathsf{middle} \\
                            \pcreturn \llst
                        }
                        \procedure[linenumbering, headlinecmd={\vspace{.1em}\hrule\vspace{.1em}}]{$\Up(\llst,\del_{x})$}{%
                            c \gets \llst.\hdr\\
                            \pcfor i \gets \llst.\lvl \ \mathbf{downto} \ 1 \pcdo\\
                            \t \pcwhile c[i] \neq \nlll \ \mathbf{and} \ c[i][0].\keyacc < x \pcdo \\
                            \t \t c \gets c[i]\\
                            c \gets c[1]\\
                            \pcif c \neq \nlll \ \mathbf{and} \  c[0].\keyacc = x \pcthen\\
                            \t c[0].\delacc = \top\\
                            \pcreturn \llst
                        }
                \end{pcvstack}	
            \end{pchstack}
    %	}
      \caption[A Robust Skip List.]{A robust, possibly ``deterministic'' (and keyed) skip list structure $\SL[\boxed{R},m,p]$ admitting insertions, deletions, and queries for any~$x \in \univ$ for some well-ordered universe~$\univ$. The parameters are an integer $m \geq 0$ representing the maximum level of the structure, a fraction~$p \in (0,1)$ used for determining an element's random level, and, if using the deterministic version of the structure, a keyed function $R: \keys \by \univ \by \mathbb{Z}^{+} \by (0,1) \to [m]$ that maps an element to a level in accordance with the distribution imposed by~$m$ and~$p$. A concrete scheme is given by a particular choice of parameters. Subroutines used by the deterministic version of the structure appear in the boxed environment. We define the~$\mathsf{append}$ operation, such that it appends an element to the end of the node array.} 
      \label{fig:rsl}
    \end{figure*}

In Figure~\ref{fig:rsl}, we give a pseudocode description of the robust skip list structure. Notably, elements can be marked are deleted by marking a ``deleted'' bit~$d$, that is stored in the node as~$\top$. It is important to point out that deleting and reinserting an element does not change the associated height, as only the $d$ bit is flipped to~$\bot$. Importantly, we do not allow for deleted elements to be replaced by subsequent insertions due to the need to preserve order-sensitive operations, and the fact that such a mechanism could be used to accelerate the gap attack we present above. 

\begin{figure}[thp]
%	\Wider[4em]{
    \centering
    \begin{pchstack}[boxed,center,space=0.5em]
        \procedure[linenumbering, headlinecmd={\vspace{.1em}\hrule\vspace{.1em}}]{Swapping mechanism for robust skip lists}{%
            \pccomment{find layer $\ell-1$ middle element using tortoise and hare} \\
            \mathsf{middle} \gets u[\ell], \; \mathsf{fast} \gets u[\ell]\\
            \pcwhile \mathsf{fast}  \neq \mathsf{x}[\ell] \ \mathbf{and} \ \mathsf{fast}[\ell-1] \neq \mathsf{x}[\ell] \pcdo \\
            \t \mathsf{middle} \gets \mathsf{middle}[\ell-1], \;
            \mathsf{fast} \gets \mathsf{fast}[\ell-1][\ell-1]\\
            \pccomment{swapping logic} \\
            \pcif \ell > \mathsf{middle}.\lvl \pcthen\\
            \t \mathsf{middle}.\mathsf{append}(\mathsf{x}[\ell]), \;
            \mathsf{x} \gets \mathsf{x}[0:\ell-1]\\
            \t u[\ell][\ell] \gets \mathsf{middle}
        }
    \end{pchstack}
%	}
  \caption[Skip List Swapping Mechanism.]{The swapping mechanism for robust skip lists, which is invoked after a node $\mathsf{x}$  has been inserted on layer $\ell$ and update vector $u$ has been constructed during this process. 
  } 
  \label{fig:swap}
\end{figure}

We use a simple swapping mechanism to make the skip list robust (depicted in~\Cref{fig:swap}). When the skip list inserts an element (denoted as $\mathsf{x}$), it first performs a standard insertion and then invokes the swapping procedure using the update vector $u$ constructed during insertion. After node $\mathsf{x}$ is inserted on layer $\ell$, the mechanism counts nodes on layer $\ell-1$ between $u[\ell]$ and $\mathsf{x}[\ell]$ ($\mathsf{x}$'s successor on level $\ell$). 

The middle element is then identified in a single pass using the tortoise and hare algorithm \cite{knuth1971art}. If the middle element is not $\mathsf{x}$ itself (verified by checking $\ell < \text{middle.lvl}$), a height swap occurs: the middle element's height increases to level $\ell$ while node $\mathsf{x}$'s height decreases to level $\ell-1$, effectively exchanging their heights.

This mechanism locally balances the skip list, preventing adversaries from creating large sequences of same-height elements that would result in search path blowup. The gap attack specifically becomes highly infeasible, as elements of a fixed height can no longer be shifted toward one side of the data structure. Instead, heights are immediately swapped at the interval's midpoint, halving long sequences of elements on level $\ell-1$. Note, this approach effectively handles corner cases where $\ell = \text{list.header}$ or $n[\ell] = \text{null}$. Moreover, the interval typically contains a constant, denoted~$a$, number of nodes with overwhelming probability, ensuring the mechanism operates in constant time with high probability.

We will formally show that our robust skip list is secure via a number of intermediary lemmas. The first of which proves a necessary condition for degenerating a skip list (including our robust version). We specifically analyze the skip list from the point of view of being able to have infinite height (we rectify this with reality before delivering our final result). One examines the set of elements that appear in the skip list strictly below level~$L(n) = \log_{1/p}(n)$, where $n$ is the number of (``deleted'' or actual) elements in the skip list (i.e., its implied capacity), and the set of elements that appear at or above level~$L(n)$.

We first relate the length of a search path (i.e., the number of nodes to be visited) to the maximal width $w$ on each level below $L(n)$, where the maximal width describes the maximal number of level $i$ elements between level $i+1$ elements in the skip list over all levels $i=0,1,\dots, L(n)-1$.  Here, we call an element a \emph{level $i$ element} if the node's height is at least $i$. In particular, any level $j$ element is also a level $i$ element for $i\le j$. We say that the element is a \emph{max-level $i$ element} if it is a level $i$ element but not a level $i+1$ element.

\begin{lemma}[Necessary Condition for Degenerating a Skip List]\label{lemma:ncdsl}
%mf: rewrote it
Consider a skip list for parameter $p\in(0,1)$ holding $n$ elements (possibly inserted by an adaptive adversary). If on all levels $i\in\{0,1,\dots, L(n)-1\}$ the number of level $i$ elements between any pair of level $i+1$ elements is at most $w$, then any search path is of length at most $2w\log_{1/p}n$, or the total number of elements on or above level $L(n)$ exceeds $w\log_{1/p}n$.
%Consider levels~$i \in \{1,2,\ldots,L(n)\}$. Then it is necessary for the adversary to craft a skip list representation where for some level~$i$ there exists~$> c$ elements between two level~$i + 1$ elements for some small constant~$c$ for there to exist a search path for an element that is greater than~$c \log_{1/p} (n)$; \emph{or} the total size of the skip list strictly above level~$L(n)$ is~$> c \log (n)$ for this same small constant~$c$. 
\end{lemma}

The lemma states that, for the adversary to create a bad skip-list representation, it may either hope that many elements are assigned a height beyond $L(n)$---which is very unlikely since the heights are determined faithfully by the data structure---or it must ensure that there is a ``degenerated'' sub-lists exceeding the width $w$ on some level. The latter matches our gap attack in Section~\ref{sec:gap-attack}, where we followed this strategy, and the lemma states that this is indeed the only valid attack strategy.

\begin{proof}
Assume that on all levels $i$, there exists at most~$w$ elements between any two elements on level $i+1$, and 
%that there exists a level above and 
that the total size of the skip list on or above level~$L(n)$ is at most $ w \log_{1/p} n$. Then the search path below level~$L(n)$ is at most $w \log_{1/p} n$ because whenever we descend to a level $i$ (and the index to be searched is thus between the indexes of both level $i+1$ elements), we make at most $w$ steps on the level $i$. This bounds the total number of steps on all levels $i$ below $L(n)$ by $w\cdot L(n)=w\cdot \log_{1/p} n$.  In addition, on level $L(n)$ or above, the total number of elements is bounded by $w \log_{1/p} n$, such that even searching all these elements cannot increase the overall number of inspected elements by more than $w \log_{1/p} n$. This yields an overall length of the search part of $2w \log_{1/p} n$.
\end{proof}

We formulate the following game to bound the number of elements on max-level~$i$ between two level~$i+1$ elements for the robust skip list. We assume that the adversary can insert as many elements as they like (up to its insertion limit~$q_U$) and that the adversary can insert into any gap arbitrarily many times. Further, observe that the adversary cannot influence the height of any particular element or alter the heights that were chosen by deletion due to our special deletion method. Then, the ability of the adversary to accrue elements that exist on level~$i$ between two level~$i+1$ elements distills down to a coin-flipping game. 

Given the number of individual trials~$n$ and probability~$p$, the game is as follows. For each individual trial, a coin (that is~$\heads$ with probability~$p$ and is~$\tails$ with probability~$1-p$) is flipped until a tail appears, at which point the particular trial is concluded. The outcome of a trial is the total number of~$\heads$ that occurred during a particular trial. For instance, the outcome~$\tails$ maps to~$0$, while the outcome~$\heads,\heads,\tails$ maps to~$2$. 

The game keeps a sequence of all the outcomes. Say the sequence at a point in time~$t-1$ is~$o_1,o_2,\ldots,o_{t-1}$. The adversary is allowed to run the next trial~$t$ anywhere within the sequence. That is, they could dictate the outcome of trial~$t$ (the result of which they do not control, as coin flips determine this) at the beginning of the sequence (before~$o_1$), at the end of the sequence (after~$o_{t-1}$), or anywhere in between two adjacent~$o_{i-1},o_{i},i \leq t-1$. The trial is then run, the outcome recorded in the sequence, and the sequence relabeled (depending on where the adversary decided to place the outcome of the most recently run trial). 

For each possible trial outcome, we have the following ``halving'' behavior concerning runs (consecutive subsequences) of outcome~$i$ for each~$i \in \{0,1,\ldots \log_{1/p}(n)\}$. If the adversary is trying to extend a particular run, they always insert it at the beginning or end of the run. By inspection of our robust skip list structure, this strategy is optimal, as it maximizes the probability of extending a particular run (by minimizing the probability of halving). Given this, when an  adversary tries to extend a run of outcome~$i$, three possible outcomes can occur:

\begin{enumerate}
    \item if the outcome of this fresh trial is~$i$, then the run extends by length~$1$;
    \item if the outcome of this trial is~$i+1$;  the length of the run is halved (or more precisely, the updated run length is the ceiling of dividing the previous run length by $2$);
    \item if the outcome of the fresh trial is any other outcome; the run length remains the same. 
\end{enumerate}

Observe that this is precisely equivalent to the procedure for an adaptive adversary inserting elements into our robust skip list with probability parameter~$p$ and insertion budget (skip list capacity)~$n = q_U$. We specifically consider the scenario where the adversary tries to accrue elements that exist on level~$0$ between two level~$1$ elements. This is because the probability of the accruing elements on this level is maximized. Looking ahead, we will cast this run width accruing game as a stochasic process that is supermartingale, generalize our result for level~$0$ to all levels~$i \in \{0,1,\ldots,\log_{1/p}(n) - 1\}$, and combine them to get a bound on the maximum search path cost over the entire robust skip list.

\begin{lemma}[Bounding Layer Sequential Elements for the Robust Skip List]\label{lemma:rsllb}
Denote~$W_i$ the random variable describing the maximum sequence of elements that exist on max-layer~$i$ between two level~$i+1$ elements for~$i \in \{0,1,\ldots,\log{1/p}(n)-1\}$ for a robust skip list. For $\epsilon>0$ and $a=\frac{2(1+p)}{p}$ let~$W$ be the event that there exists $W_i> a(1+\epsilon)$ for some $i \in \{0,1,\ldots,L(n)-1\}$, then
\[\Pr[W]  \leq e^{(\lambda^{*}a) - (\epsilon\lambda^{*}a)},\]
where ~$\lambda^{*}$ is the maximal solution~$\lambda > 0$ to
$$(1-p)e^{\lambda} + p(1-p)e^{-\lambda \left(\frac{1}{p} + \frac{a}{2} \right)} + p^2 \leq 1 .$$
\end{lemma}

\begin{proof}
\textit{Defining the Probabilistic Process.} We begin by considering the adversary trying to accrue a run of outcome~$0$. Given the adversary can play many independent trials, indexed by integer~$t$ (and in reality bounded by~$n=q_U$), we define a counter tracking the run length~$X_t$, initialized to~$0$, that is updated as follows:

    \[ X_{t+1} = \begin{cases} 
          X_t +1 & \text{with probability } 1-p \\
           \left\lceil \frac{X_t}{2} \right\rceil & \text{with probability } p(1-p) \\
          X_t & \text{with probability } 1 - ((1-p) + p(1-p) = p^2 \\
       \end{cases}
    \]

For~$X_t = x$,
\begin{align*}
    \mathbb{E}[X_{t+1} | X_t = x] &= (1-p)(x+1) + p(1-p)(\frac{x}{2} +1) + p^2x \\
    &= \left((1-p)+\frac{p(1-p)}{2}+p^2\right)x + (1-p)+p(1-p) \\
    & = \left(1 - \frac{p}{2} + \frac{p^2}{2} \right)x + 1-p^2,
\end{align*}
where we approximate~$\left\lceil \frac{x}{2} \right\rceil$ as~$\frac{x}{2} + 1$.

Setting~$A = \left((1-p)+\frac{p(1-p)}{2}+p^2\right)$ and~$D = 1-p^2$, we can solve for a fix point (i.e., the steady-state solution where the drift is zero) by solving~$a = Aa + D = a(1-A) = D$:

$$a = \frac{D}{1-A} = \frac{1-p^2}{\frac{p(1-p)}{2}} = \frac{2(1+p)}{p}.$$

Therefore, for any,~$p$ the fixed point is~$a = \frac{2(1+p)}{p}$.\\

\textit{Bounding the Process for Outcome~$0$.} 
We next cast this process as martingale to be able to apply a concentration bound. Specifically, for trying to accrue a run of outcome~$0$, we define the process

$$M_t = e^{(\lambda(X_t - a))},$$

where~$\lambda > 0$ is a parameter to be selected. Our goal is to show that when~$X_t$ exceeds a certain threshold (say~$x \geq a + B$ for some constant~$B > 0$), the process~$M_t$ is supermartingale. That is for all~$x \geq a + B, \mathbb{E}[M_{t+1} | X_t = x] \leq M_t$. 

Using the update rule for our process, we have for~$X_t = x$:
\begin{align*}
    \mathbb{E}[M_{t+1} | X_t = x] &= (1-p)e^{\lambda((x+1)-a) + p(1-p)e^{\lambda}((x/2+1)-a) + p^2e^{\lambda(x-a)}} \\
    &= e^{\lambda(x-a)} \left( (1-p)e^{\lambda} + p(1-p)e^{\lambda(1-x/2)}+p^2 \right).
\end{align*}

Observe that since the term~$e^{\lambda1-x/2}$ decreases in~$x$, the worst case for~$x \geq a+B$ is exactly at~$x=a+B$. Hence, it suffices to have
$$(1-p)e^{\lambda} + p(1-p)e^{\lambda(1-a+B/2)}+p^2 \leq 1$$
for our stochastic process to satisfy the supermartingale condition. 

Further, we have~$\frac{a+b}{2} = \frac{1+p}{p} + \frac{B}{2}$ and $1 - \frac{a+B}{2} = -\frac{1}{p} - \frac{B}{2}$, thus, our condition simplifies to
$$(1-p)e^{\lambda} + p(1-p)e^{-\lambda \left( \frac{1}{p} - \frac{B}{2} \right)} + p^2 \leq 1.$$

For any fixed~$p \in (0,1)$ and chosen~$B>0$ (in practice we chose~$B$ to be a small constant that is~$\approx a$), one can solve for that largest~$\lambda$ that satisfies this inequality; denote this~$\lambda^{*} = \lambda(p,B)$. 

Now, define a stopping time
$$t_0 = \min \{ t \geq 0 : X_t \geq a + B \}.$$

At this stopping time, we have 
$$M_{t_0} = e^{\lambda^{*}(X_{t_0} - a)} \leq e^{\lambda^{*}B},$$
as~$X_{t_{0}} \geq a+B$. We then work with the stopped process~$M_{t \land t_0}$ (or more precisely with the process from time $t_0$ onward) and apply Ville's inequality~\cite{ville1939etude}. This yields for all~$k \geq 0$
$$\Pr \left[ \underset{0 \leq t_0 \leq n}{\max} X_t \geq a + k \right] \leq \frac{\mathbb{E}[M_{t_0}]}{e^{\lambda^{*}k}} \leq e^{\lambda^{*}B}e^{-\lambda^{*}k}.$$

Define~$C = e^{\lambda^{*}B}$, we then obtain the concentration bound for outcome~$0$ for all~$k \geq 0$:
$$\Pr [X_n \geq a + k] \leq Ce^{-\lambda^{*}k}.$$

Recasting in the multiplicative form (as~$(1+\epsilon)a = a + \epsilon a$), for any~$\epsilon > 0$ we have
$$\Pr[X_t \geq (1 + \epsilon)a] \leq Ce^{-\lambda^{*} \epsilon a}.$$\\

\textit{Lifting Result to All Outcomes.} Next, we use a chaining argument to lift our result to the maximum over all outcomes~$ j \in \{ 0,1,\ldots,\log_{1/p}(n)-1 \} $.

Let~$X_{n}^{(j)}$ denote the run length process for outcome \\ $j \in \{0,1,\ldots,\log_{1/p}(n)-1\}$. Observe that the probability of outcome~$j$ is~$p^{j}(1-p)$ and the outcome~$j+1$ is~$p^{j+1}(1-p)$. Thus, the ratio is
$$\frac{p^{j}(1-p)}{p^{j+1}(1-p)}=\frac{1}{p},$$
which is independent of~$j$. In turn, the fixed point~$a = \frac{2(1+p)}{p}$ is identical (up to a constant additive error) for every outcome~$j$. Therefore, for each~$j$, we have
$$\Pr \left[ \underset{0 \leq t_0 \leq n}{\max} X_t^{(j)} \geq a + k \right] \leq Ce^{-\lambda^{*}k}.$$

A naive union bound would suggest
$$\Pr \left[ \max_{j=0}^{\log_{1/p}(n)-1} \underset{0 \leq t_0 \leq n}{\max} X_t^{(j)} \geq a + k \right] \leq \log_{1/p}(n)Ce^{-\lambda^{*}k}.$$ 

However, using a standard chaining and peeling argument~\cite{bound_book} we can show that in fact, there exist constants~$C',\lambda' > 0$ (depending only on~$p$) such that 
$$\Pr \left[ \max_{j=0}^{\log_{1/p}(n)-1} \underset{0 \leq t_0 \leq n}{\max} X_t^{(j)} \geq a + k \right] \leq C'e^{-\lambda^{'}k},$$

or equivalently, for any~$\epsilon > 0,$

$$\Pr \left[ \max_{j=0}^{\log_{1/p}(n)-1} \underset{0 \leq t_0 \leq n}{\max} X_t^{(j)} \geq (1 + \epsilon)a  \right] \leq C'e^{-\lambda^{'} \epsilon a}.$$

In practice, we simply take~$C' \approx C$ and~$\lambda' \approx \lambda^{*} = \lambda(p,B)$ (the same constants as above for outcome~$0$), as there is at most a negligible difference between the bound for different outcomes in~$\{0,1,\ldots,\log_{1/p}(n)-1\}$ and the bound is maximized at outcome~$0$. Then, by choosing~$B=a$, we obtain our result in the lemma. 
\end{proof}

\begin{lemma}[Overall Robust Skip List Search Path Cost]\label{lemma:rslspc}
 For $\epsilon>0$ and $a=\frac{2(1+p)}{p}$, let~$S$ be the total search path cost of the robust skip list, , then \[\Pr[S \geq a(1+\epsilon) \log_{1/p}(n)]  \leq e^{(\lambda^{*}a) - (\epsilon\lambda^{*}a)},\]
 where~$\lambda^{*}$ is the maximal solution~$\lambda > 0$ to
 $$(1-p)e^{\lambda} + p(1-p)e^{-\lambda \left(\frac{1}{p} + \frac{a}{2} \right)} + p^2 \leq 1 .$$
\end{lemma}

\begin{proof}
The lemma directly follows from~\cref{lemma:rsllb}, and the fact that
\begin{align*}
    S &= \sum_{j=0}^{\log_{1/p}(n)} X^{(j)} \\
      &\leq \sum_{j=0}^{\log_{1/p}(n)} max_{j=0}^{\log_{1/p}(n)-1} \underset{0 \leq t_0 \leq n}{\max} X_t^{(j)}.
\end{align*}
\end{proof}

Next, we bound the number of elements in a skip list above level~$L(n) = \log_{1/p}(n)$, addressing the second point in~\cref{lemma:ncdsl}. 

\begin{lemma}[Bound on the Size of the list Above Level~$L(n)$]\label{lemma:lvlbound}
    Given a (robust) skip list with probability parameter~$p$, let $H$ be the number of elements that appear at heights~$\geq L(n) = \log_{1/p}(n)$. That is, $H$ counts the total occurrences of elements at or above height~$L(n)$ resp.~the total size of the skip list at or above height~$L(n)$. Then,
    \[ \mathbb{E}[H] = \frac{1}{1-p}, \]
    and
    \[ \Pr\left[H \geq w \cdot \log_{1/p}(n)\right] \leq e^{-\frac{w\log_{1/p}(n)-1}{3}}. \]
\end{lemma}

\begin{proof}
    Let $H_i\sim \operatorname{Bin}(n,p^i)$ denote the random variable describing the number of elements on level $i$ among the $n$ elements, such that $\mathbb{E}[H_i]=np^i$.
    Let $H = \sum_{i \ge L(n)} H_i$ be the total number of times an element appears at some level in all levels above level $L(n) = \log_{1/p}(n)$. Then,
    \[ \mathbb{E}[H] = \sum_{i \ge L(n)} np^{i} = np^{L(n)} \sum_{j \geq 0} p^{j} = np^{L(n) } \frac{1}{1-p}. \]
    Now, observe that $p^{L(n)} = p^{\log_{1/p}(n)} = n^{\log_{1/p} p} = n^{-1}$, in turn $np^{L(n) } = n \cdot p^{L(n)} = n \cdot \frac{1}{n}  = 1$. Therefore, the expected number of elements that appear at any level on or above level~$L(n)$ is
    \[ \mathbb{E}[H] = \frac{1}{1-p}. \]
    We then obtain a tail bound via the standard Chernoff bound, solving for a value $\delta$\footnote{Here~$\delta$ refers to the usual difference from the mean in the Chernoff bound, not the parameter of the AAPC security notion.} such that~$(1+\delta)\left(\frac{1}{1-p}\right) = w \log_{1/p}(n)$. This completes the proof. The value $\delta=(1-p)w\log_{1/p}(n)-1$ works, and we get the upper bound of $\exp\left(-\frac{\delta}{3(1-p)}\right)$.
\end{proof}

In our robust skip list, we define a maximum level~$m$. This, in turn, defines the capacity of the list~$n$ by solving~$m = \log_{1/p}(n) = L(n)$. So, in reality, this result actually reflects the maximum number of elements on level~$L(n)$. To win in our game, the adversary must either craft a structure such that the total search path cost below level~$L(n)$ exceeds~$w \log_{1/p}(n)$ or the above ``bad'' event happens where there exists more than~$w \log_{1/p}(n)$ elements on level~$L(n)$. Combining these results gives us the following theorem.

\begin{theorem}[Robust Skip List AAPC Security Result]\label{thm:rslsr}
    Let~$\Pi$ be the robust skip list from Figure~\ref{fig:rsl} with parameters~$p \in [0,1]$ and $m = \log_{1/p}(q_U)$. For integers~$q_U,q_Q,t \geq 0$, it holds that~$\Pi$ is~$(\phi,\beta,\epsilon,\delta,t)$-conserved with $\phi$ being the Maximum Search Path Cost function (Figure~\ref{fig:sl-cost}), $\beta = c \log_{1/p}(n)$, $\epsilon > 0 $, and 
    $$\delta = e^{(\lambda^{*}a) - (\epsilon\lambda^{*}a)} + e^{-\frac{a\log_{1/p}(n)-1}{3}},$$
    where~$a=\frac{2(1+p)}{p}$, $c = a(\epsilon + 1)$, and~$\lambda^{*}$ is the maximal solution~$\lambda > 0$ to
 $$(1-p)e^{\lambda} + p(1-p)e^{-\lambda \left(\frac{1}{p} + \frac{a}{2} \right)} + p^2 \leq 1 .$$
\end{theorem}

\begin{proof}
    The theorem directly follows from the observation deletions do not help the adversary as with our robust hash table and \Cref{lemma:ncdsl}, \Cref{lemma:rslspc}, and~\Cref{lemma:lvlbound}.
    \qed
\end{proof}

To give a concrete illustration of this bound, suppose we had~$n = 2^{32}$, $p=\frac{1}{2}$. Then our fixed point~$a = 6$, and solving for~$\lambda^{*}$ numerically yields~$\lambda^{*} \approx 0.34$. Then, choosing~$\epsilon = 8$ (hence, $c=54$), the probability that the maximum search cost path exceeds~$54 \log_{1/p}(n)$ is less than or equal to~$\delta =  6.28 \times 10^{-7}$. While a constant~$c = 54$ may appear large, consider that that,~$\lambda^{*}$ solely depends on~$p$. In turn, for any fixed~$\epsilon$ this bound is constant as~$n\to\infty$, showing that our adaptive search path is indeed~$O(\log n)$. We further, remark that this constant is likely ``artificially'' large, in the sense that the stochastic process we bound is complex, leaving us only to be able to use blunt Markov-like concentration bounds.

\subsection{Robust Skip Lists in Real World Deployments}

Skip lists, like hash tables, have an explicit capacity for a set number of elements and require resizing when exceeded. While skip lists do not require upfront memory allocation, they require setting a maximum node height of $m=\log_{\frac{1}{p}} n$ for expected $n$ insertions. Exceeding $n$ insertions necessitates resizing as the probabilistic guarantees otherwise deteriorate~\cite{pugh}. Our security analysis avoids considering attacks that trigger re-initialization by enforcing~$m = \log_{\frac{1}{p}} q_U$/
We now evaluate how our modifications affect resizing frequency in practice.

Standard skip lists with $I$ successful insertions and $D$ successful deletions require resizing when $\log_{\frac{1}{p}} (I-D) > m$. Previously, structures could operate indefinitely without resizing if insertion and deletion rates remained balanced. Our modified structure, which merely marks elements as "deleted" without allowing replacement, requires resizing when $\log_{\frac{1}{p}} (I) > m$ regardless of remaining elements. This allows adversaries to trigger early resizing by inserting approximately $\left(\frac{1}{p}\right)^m$ elements, deleting most, then forcing a resize with few additional insertions.

Unlike hash tables, we cannot replace deleted nodes without creating a security vulnerability where adversaries could manipulate the skip list by strategically deleting elements and inserting new ones, effectively repositioning unfavorable heights in other parts of the skip list -- essentially enhancing our gap attack. While our approach requires more frequent resizing, this represents an essential trade-off ensuring provable robustness against adaptive adversarial attacks while preserving expected performance characteristics.
